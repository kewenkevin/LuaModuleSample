--- UI数仓元表处理
--- 对data的wrap操作
--- Generated by EmmyLua(https://github.com/EmmyLua)
---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------
---
---@class UIDataStorageFactory
local UIDataStorageFactory = class("UIDataStorageFactory")

UIDataStorageFactory.luaUIModulesPathPrefix = ""

---@param targetUIBase UIBase
function UIDataStorageFactory.generate(uiExpansion, data, methods, modules, observerUIData, targetUIBase)
    local metaTable = UIDataStorageFactory._getWrappedMetaTable(uiExpansion, data, methods, modules, observerUIData, targetUIBase)
    local data = setmetatable(data, metaTable)
    metaTable._onWrapped()
    return data
end

---_getWrappedMetaTable
---@param targetUIBase UIBase
function UIDataStorageFactory._getWrappedMetaTable(uiExpansion, data, methods, modules, observerUIData, targetUIBase)
    local EmptyModule = require("LuaModules.UILib.Base.EmptyModule")
    local UILinkerUtils = require("LuaModules.UILib.Enums.UILinkerUtils")

    --region 属性设置
    local metaTable = {}
    --非模组数组简单数据map
    metaTable._values = {}
    --methods map
    metaTable._methods = {}
    --非模组数组简单数据闭包生成的set方法map
    metaTable._handlers = {}
    --模组数组闭包生成的set方法map
    metaTable._arrHandlers = {}
    
    metaTable._modifyHandlers = observerUIData
    metaTable.uiExpansion = uiExpansion
    
    --初次构造绑定时触发改变需要延迟调用的cache
    metaTable._cachedNotification = {}
    --endregion


    --------------------------------------------------------------------------------------------------------------------------------------
    --region 私有方法
    --list数组的绑定特殊处理
    metaTable._setObjectValue = function(key, listArrayTable, emitMethods)
        if listArrayTable == nil then
            return ;
        end
        local valType
        if listArrayTable.type then
            valType = listArrayTable.type
        else
            valType = "array"
        end
        if valType ~= "array" and valType ~= "table" then
            error("must use type == array or table:  " .. key)
        end
        if valType == "array" then
            
            ---条目使用的皮肤数据源，For GridView的皮肤支持
            listArrayTable.getIdentify = function(id)
                if #listArrayTable <= 0 then
                    return ""
                end
                if id + 1 > #listArrayTable then
                    return nil
                end
                local i = listArrayTable[id + 1].identify
                if i then
                    return i
                else
                    return nil
                end
            end
            
            ---解绑时的调用，如list拖动导致条目回池
            listArrayTable.getItemClsUnbind = function(id)
                local mds = modules[key]
                if mds then
                    local m = mds[id + 1]
                    if m then
                        if m.unBind then m:unBind() end
                    end
                end
                return nil
            end
            
            ---列表获取对应index条目的绑定，之后C#侧会嗲用bind，使其完成绑定，虚拟列表只绑定了可视条目
            listArrayTable.getItemCls = function(id, uiExpansionLuaBindPath)
                if #listArrayTable <= 0 then
                    return nil
                end
                
                local listModuleArray = modules[key] or {}
                modules[key] = listModuleArray;

                --C#传递过来的ID是以0开始，lua数组索引需要+1
                local luaIndex = id + 1
                ---@type UIModuleBase
                local itemModule = listModuleArray[luaIndex]
                local itemValue = listArrayTable[luaIndex]
                if itemValue == nil then
                    return nil
                end
                
                itemValue.index = luaIndex

                --region 计算Lua侧使用的moudleBase类到底是用哪一个
                --优先采用子键值的自己的moduleName
                --getModulePath
                local modulePath
                if G_DEFINE_UI_LUA_BIND_MODE == 0 then
                    --强制资源绑定模式
                    if uiExpansionLuaBindPath and uiExpansionLuaBindPath ~= "" then
                        modulePath = uiExpansionLuaBindPath
                    end
                elseif G_DEFINE_UI_LUA_BIND_MODE == 2 then
                    --强制代码绑定方式 忽略资源绑定
                    if listArrayTable.moduleName then
                        modulePath = UIDataStorageFactory.luaUIModulesPathPrefix .. listArrayTable.moduleName
                    end

                    --然后如果没有则使用整体的moduleName
                    if not modulePath and itemValue.moduleName then
                        modulePath = UIDataStorageFactory.luaUIModulesPathPrefix .. itemValue.moduleName
                    end
                else
                    --灵活模式，资源绑定优先，代码次之
                    if listArrayTable.moduleName then
                        modulePath = UIDataStorageFactory.luaUIModulesPathPrefix .. listArrayTable.moduleName
                    end

                    --然后如果没有则使用整体的moduleName
                    if not modulePath and itemValue.moduleName then
                        modulePath = UIDataStorageFactory.luaUIModulesPathPrefix .. itemValue.moduleName
                    end
                    --然后使用uiExpansion上有绑定的LuaBindPath 则强制使用 强制代码模式则不生效
                    if uiExpansionLuaBindPath and uiExpansionLuaBindPath ~= "" then
                        modulePath = uiExpansionLuaBindPath
                    end
                end
                --endregion


                if itemModule == nil or (modulePath~=nil and itemModule.__modulePath ~= modulePath) then
                    --如果没有合适的路径，则直接使用空模块创建，空模块自身不完成封装，全部依赖外部传入， 一般不推荐，除非非常简单的模块
                    if modulePath == nil then
                        itemModule = EmptyModule.new()
                    else
                        itemModule = require(modulePath).new(nil)
                    end

                    if itemModule.created then
                        itemModule:created(itemValue, emitMethods, targetUIBase)
                    end
                    --数据引用回迁，保证UI中可以self.data.listA[2].label1这样的访问
                    listArrayTable[luaIndex] = itemModule.data
                    --模块索引赋值
                    listModuleArray[luaIndex] = itemModule
                else
                    --已有缓存则直接合并
                    itemModule.data = itemModule:mergeData(listArrayTable[luaIndex], itemModule.data)
                    listArrayTable[luaIndex] = itemModule.data
                end

                if itemModule ~= nil then
                    itemModule.__modulePath = modulePath
                end
                
                return itemModule
            end
            
            ---列表时绑定时被告知table改变，通过该方法获取列表元素数量，然后开始触发重用与回池逻辑
            listArrayTable.getCellSize = function(id)
                if #listArrayTable <= 0 then
                    return 0
                end
                local v = listArrayTable[id + 1]
                if v == nil then
                    return 0
                end
                if v.size ~= nil then
                    if type(v.size) == "number" then
                        return v.size
                    else
                        return 0
                    end
                else
                    return 0
                end
            end
            
            
            --核心处理逻辑 列表此时回按照新的数据开始计算显示原件数量，并开始由每个Item触发构建ModuleBase对象
            metaTable._values[key] = listArrayTable
            metaTable.uiExpansion:LinkerSetSystemObject(key, listArrayTable)
        else
            error("dont support this type in key:" .. key .. "  " .. valType)
        end
    end

    --普通有绑定对象的set方法实现
    metaTable._setValue = function(key, t, val, isFirstBind)
        if val == nil then return end
        if not targetUIBase:_trigCheck(targetUIBase,key,val) then return end
        if metaTable._changeValue(key, val, isFirstBind) then
            UILinkerUtils.setLinkerValue(targetUIBase, metaTable, key, t, val)
        end
    end

    --普通无绑定对象的set方法实现
    metaTable._setValueNoLinker = function(key, val, isFirstBind)
        if val == nil then return end
        if not targetUIBase:_trigCheck(targetUIBase,key,val) then return end
        metaTable._changeValue(key, val, isFirstBind)
    end
    
    --方法绑定
    metaTable._setMethods = function(key, t, val)
        --print(tag,key,t)
        if val == nil then
            return
        end
        if metaTable._methods[key] then
            error("dont support multi bind methods\n method only support bind once:  " .. key)
        end
        if type(val) ~= "function" then
            error("methods must a function: " .. key)
        end
        UILinkerUtils.setLinkerFunction(targetUIBase, metaTable, key, t)
        metaTable._methods[key] = val
    end

    --实际改变数据的操作
    metaTable._changeValue = function(key, newVal , isFirstBind)
        local oldVal = metaTable._values[key]
        local typeVal = type(newVal)
        local basicType = (typeVal == "number" or  typeVal =="string" or typeVal =="boolean")
        if oldVal == newVal and basicType then
            return false
        else
            metaTable._values[key] = newVal
            if isFirstBind then
                metaTable._cachedNotification[key] = { old = oldVal, new = newVal }
            else
                metaTable._invokeChangedFunction(key,oldVal, newVal)
            end
            if metaTable._values[key] ~= newVal and basicType then
                return false
            end
            return true
        end
    end

    --数据改变监听
    metaTable._invokeChangedFunction = function(key, param1, param2, extentKey)
        local funcName = extentKey and key .. extentKey or key
        local func = metaTable._modifyHandlers[funcName]
        if func and type(func) == "function" then
            func(targetUIBase,param1,param2)
        end
        targetUIBase:_trigObservers(targetUIBase,funcName)
    end

    --绑定完成后延迟调用方法，触发首次数据改变的ObserverUIData
    metaTable._onWrapped = function()
        for key, v in pairs(metaTable._cachedNotification) do
            metaTable._invokeChangedFunction(key,v.old, v.new)
        end
        metaTable._cachedNotification = {}
    end

    --endregion

    --------------------------------------------------------------------------------------------------------------------------------------
    --region setter && getter
    ---get 数据获取的核心入口
    metaTable.__index = function(t, k)
        local v = metaTable._values[k]
        if v == nil and modules[k] then
            v = modules[k].data
        end
        return v
    end

    ---set 数据改变的核心入口
    metaTable.__newindex = function(t, k, v)
        if type(v) == "table" and targetUIBase.linkerDataDict[k] == UILinkerUtils.EnumLinkerTypeId.SystemObject then
            local handler = metaTable._arrHandlers[k]
            if handler then
                return handler(v)
            else
                if not targetUIBase:_trigCheck(targetUIBase,k,v) then
                    return
                end
                
                local oldValue = metaTable._values[k]
                if oldValue == nil and modules[k] then
                    oldValue = modules[k].data
                    modules[k].data = modules[k]:mergeData(v, modules[k].data)
                else
                    metaTable._values[k] = v
                end

                if oldValue ~= metaTable._values[k] then
                    --数据修改事件
                    metaTable._invokeChangedFunction(k,oldValue,v)
                end
            end
        else
            local handler = metaTable._handlers[k]
            if handler then
                return handler(v)
            else
                local old = metaTable._values[k]
                if not targetUIBase:_trigCheck(targetUIBase,k,v) then
                    return
                end
                if old == nil and modules[k] then
                    old = modules[k].data
                    modules[k].data = modules[k]:mergeData(v, modules[k].data)
                else
                    metaTable._values[k] = v
                end
                if old ~= metaTable._values[k] then
                    --数据修改事件
                    metaTable._invokeChangedFunction(k,old, v)
                end
            end
        end
    end
    --endregion
    --------------------------------------------------------------------------------------------------------------------------------------
    
    --region 增删改辅助
    ---插入
    metaTable._values.insert = function(k, v)
        if not targetUIBase:_trigCheck(targetUIBase,k,v) then
            return
        end
        
        table.insert(metaTable._values[k], v)
        metaTable.uiExpansion:LinkerSetSystemObject(k, metaTable._values[k])

        --数据修改事件
        metaTable._invokeChangedFunction(k,v,nil,"_insert")
    end

    ---删除
    metaTable._values.remove = function(k, v)
        if v > #metaTable._values[k] then
            return
        end
        table.remove(metaTable._values[k], v)
        metaTable.uiExpansion:LinkerSetSystemObject(k, metaTable._values[k])

        --数据修改事件
        metaTable._invokeChangedFunction(k,v,nil,"_remove")
    end

    ---清空
    metaTable._values.clear = function(k, linker)
        --if linker == nil then linker = true end
        linker = linker  == nil and true or linker
        local v = metaTable._values[k]
        if v then
            for i, x in ipairs(v) do
                v[i] = nil
            end
            --数据修改事件
            metaTable._invokeChangedFunction(k,nil,nil,"_clear")
        end
        
        if linker == true then
            metaTable.uiExpansion:LinkerSetSystemObject(k, metaTable._values[k])
        end
    end
    --endregion
    
    --------------------------------------------------------------------------------------------------------------------------------------
    --region 为了动态module准备的函数 for YModuleContainer
    metaTable.getAndCreateModuleCls = function(moduleName, luaBindPath)
        local d = data[moduleName]
        local ms = methods[moduleName]

        local m =  modules[moduleName]
        if m ~= nil then
            return m
        end

        if luaBindPath == nil or luaBindPath == "" then
            m = EmptyModule.new()
        else
            m = require(luaBindPath).new(nil)
        end
        m:created(d, ms, targetUIBase)
        modules[moduleName] = m
        data[moduleName] = m.data
        return m
    end
    
    metaTable.getAndRemoveModuleCls = function(moduleName)
        if modules[moduleName] then
            return modules[moduleName]
        end
        return nil
    end
    
    metaTable.onModuleUnBinded = function(moduleName)
        local m =  modules[moduleName]
        if m == nil then
            return nil
        end
        data[moduleName] = m.data
        modules[moduleName] = nil
        return nil
    end
    --endregion

    --------------------------------------------------------------------------------------------------------------------------------------

    --region 解绑时调用的 的数据从元表回归rawTable的方法
    metaTable.revertDataToRawTable = function(sourceTable)
        local ret = sourceTable or {}
        setmetatable(ret,nil)
        for k, v in pairs(metaTable._values) do
            if type(v) ~= "function" then
                ret[k] = v
            end
        end
        for k, v in pairs(modules) do
            local meta = getmetatable(v.data)
            if meta and meta.revertDataToRawTable then
                ret[k] = meta.revertDataToRawTable(ret[k])
            end
        end
        return ret
    end
    --endregion
    
    --------------------------------------------------------------------------------------------------------------------------------------
    
    --region 元表构造时执行内容

    local addedLinkers = {}
    --step1. 常规有linker的绑定数据处理
    if targetUIBase.linkerDatas ~= nil then
        for i = 0, targetUIBase.linkerDatas.Length - 1 do
            local linker = targetUIBase.linkerDatas[i]
            local key = linker.Label
            if not addedLinkers[key] then
                local t = linker.ValueTypeId
                --目前SystemObject专门给luaTable的传递使用，这里是list的数组处理
                if t == UILinkerUtils.EnumLinkerTypeId.SystemObject then
                    metaTable._setObjectValue(key, data[key], methods[key])
                    metaTable._arrHandlers[key] = function(val)
                        metaTable._values.clear(key, false)
                        local oldVal = metaTable._values[key]
                        for k, v in ipairs(val) do
                            table.insert(oldVal, v)
                        end
                        metaTable.uiExpansion:LinkerSetSystemObject(key, oldVal)
                    end
                --其他绑定的处理，大于UnityEvent的都是事件绑定，下面else中处理
                elseif t < UILinkerUtils.EnumLinkerTypeId.UnityEvent then
                    local dataValue = data[key]
                    local dataType = type(dataValue)
                    if dataType == "string" and dataValue == "nil" then
                    else
                        if dataType == "function" then
                            metaTable._setValue(key, t, data[key](), true)
                        else
                            metaTable._setValue(key, t, data[key], true)
                        end
                    end
                    metaTable._handlers[key] = function(val)
                        metaTable._setValue(key, t, val)
                    end
                --处理事件绑定
                else
                    metaTable._setMethods(key, t, methods[key])
                end
                addedLinkers[key] = true
                if data[key] ~= nil then
                    data[key] = nil
                end
            else
                warn("dont support multi key " .. key)
            end
        end
    end
    --step2. 常规有module的绑定数据处理

    --注意：这里必须清一次，因为动态模块的绑定和moduleName的string的linker公用，上面赋值一次string后，这里需要将table传给binder必须赋值，所以这里不用排重，只需要排除modulelinker的重复即可
    addedLinkers = {}

    if targetUIBase.moduleLinkerDatas ~= nil then
        for i = 0, targetUIBase.moduleLinkerDatas.Length - 1 do
            local linker = targetUIBase.moduleLinkerDatas[i]
            local key = linker.Label
            if not addedLinkers[key] then
                metaTable.uiExpansion:LinkerSetSystemObject(key, metaTable)
                addedLinkers[key] = true
            else
                warn("dont support multi key " .. key)
            end
           
        end
    end
    --step3. 常规动态module的绑定数据处理 for YModuleContainer
    if targetUIBase.moduleDatas ~= nil then
        local moduleLinked = {}
        for i = 0, targetUIBase.moduleDatas.Length - 1 do
            local modUIExpansion = targetUIBase.moduleDatas[i]
            local key = modUIExpansion.Label
            if not moduleLinked[key] then
                local d = data[key]
                local m = methods[key]
                local ms = nil
                if m ~= nil then
                    if type(m) == "table" then
                        ms = m
                    end
                end
                if d == nil then
                    d = {}
                end
                local modulePath
                local uiExpansionLuaBindPath = modUIExpansion.UI.LuaBindPath
                if G_DEFINE_UI_LUA_BIND_MODE == 0 then
                    --强制资源绑定模式
                    if uiExpansionLuaBindPath and uiExpansionLuaBindPath ~= "" then
                        modulePath = uiExpansionLuaBindPath
                    end
                elseif G_DEFINE_UI_LUA_BIND_MODE == 2 then
                    --强制代码绑定方式 忽略资源绑定
                    if d.moduleName then
                        modulePath = UIDataStorageFactory.luaUIModulesPathPrefix .. d.moduleName
                    end
                else
                    --灵活模式，资源绑定优先，代码次之
                    if d.moduleName then
                        modulePath = UIDataStorageFactory.luaUIModulesPathPrefix .. d.moduleName
                    end
                    --然后使用uiExpansion上有绑定的LuaBindPath 则强制使用 强制代码模式则不生效
                    if uiExpansionLuaBindPath and uiExpansionLuaBindPath ~= "" then
                        modulePath = uiExpansionLuaBindPath
                    end
                end

                local module = nil
                if modulePath == nil then
                    module = EmptyModule.new()
                else
                    module = require(modulePath).new()
                end
                module:setExpansion(modUIExpansion.UI)
                module:created(d, ms, targetUIBase)
                modules[key] = module
                moduleLinked[key] = true

                if data[key] ~= nil then
                    data[key] = nil
                end
            else
                warn("dont support multi key " .. key)
            end
        end
    end
    --step4. 其他无绑定常规数据处理
    for key, v in pairs(data) do
        if v ~= nil then
            local dataType = type(v)
            if dataType == "string" and v == "nil" then
            else
                if dataType == "function" then
                    if key ~= "insert" and key ~= "remove" and key ~= "clear" then
                        metaTable._setValueNoLinker(key, data[key](), true)
                        metaTable._handlers[key] = function(val)
                            metaTable._setValueNoLinker(key, val)
                        end
                        data[key] = nil
                    end
                elseif data[key] ~= nil then
                    metaTable._setValueNoLinker(key, data[key], true)
                    metaTable._handlers[key] = function(val)
                        metaTable._setValueNoLinker(key, val)
                    end
                    data[key] = nil
                end
            end
        end
    end
    --endregion
    --------------------------------------------------------------------------------------------------------------------------------------

    
    --------------------------------------------------------------------------------------------------------------------------------------
    return metaTable
end

return UIDataStorageFactory