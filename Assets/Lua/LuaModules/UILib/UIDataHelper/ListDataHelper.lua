---
--- Generated by EmmyLua(https://github.com/EmmyLua)

---@class ListDataHelper
---@field multiSelectable boolean
---@field allowSwitchOff boolean
---@field onItemSelect SingleEventDispatcher
local ListDataHelper = class2("ListDataHelper")

---ctor
---@param hostUIBase UIBase 
---@param hostDataName string
function ListDataHelper:ctor(hostUIBase,hostDataName,cellSelectedTag)
    self.hostUIBase = hostUIBase
    self.hostDataName = hostDataName
    self.cellSelectedTag = cellSelectedTag or "selected"
    
    self._multiSelectable = false
    self._allowSwitchOff = false
    
    
    self.onItemSelect = require("LuaModules.Event.SingleEventDispatcher").new()
    self:__initSelectIndexes();
end


---allowSwitchOff 访问器方法， 是否可以关闭选择
function ListDataHelper.Get:allowSwitchOff()
    return self._allowSwitchOff
end

---allowSwitchOff 访问器方法， 是否可以关闭选择
---@param value boolean
function ListDataHelper.Set:allowSwitchOff(value)
    self._allowSwitchOff = value
end


---multiSelectable 访问器方法， 是否多选
function ListDataHelper.Get:multiSelectable()
    return self._multiSelectable
end

---multiSelectable 访问器方法， 是否多选
---@param value boolean
function ListDataHelper.Set:multiSelectable(value)
    if self._multiSelectable~= value then
        self._multiSelectable = value
        --多选变 单选模式
        if not value then
            if self._lastSelectIndex == 0 then
                for i, v in pairs(self.mappedSelectIndices) do
                    if v then
                        self._lastSelectIndex = i
                        break
                    end
                end
                if self._lastSelectIndex ~= 0 then
                    self:setIndexSelected(self._lastSelectIndex,true)
                else
                    --self.mappedSelectIndices[self._lastSelectIndex] = {}
                    self:setIndexSelected(1,true)
                end
            end
        else-- 单选模式变多选


        end
        
        
        
    end
end


---selectIndex 访问器方法， 获取上次选中的索引号，如果是多选，且上次取消了选中，则重置为0
function ListDataHelper.Get:selectIndex()
    return self._lastSelectIndex
end


---selectIndex 访问器方法，设置选中
---@param value number
function ListDataHelper.Set:selectIndex(value)
    self:setIndexSelected(value,true)
end


function ListDataHelper:__initSelectIndexes()
    self._lastSelectIndex = 0
    self.mappedSelectIndices = {}
    local arrData = self:__getArrData();
    if  self.observerHandler == nil then
        self.observerHandler = handler(self,self.__observer)
    end
    self.hostUIBase:injectObservers(self.observerHandler);
    
    for i, v in ipairs(arrData) do
        if(v[self.cellSelectedTag])then
            self.mappedSelectIndices[i] = true
            if self._lastSelectIndex == 0 then
                self._lastSelectIndex = i
            end
        end
    end
end

function ListDataHelper:setIndexSelected(selectIndex, enable)
    local arrData = self:__getArrData()
    
    local cellData = arrData[selectIndex]
    --单选模式
    if not self._multiSelectable then
        if enable then
            local needclosed = self.mappedSelectIndices
            self.mappedSelectIndices = {}
            self.mappedSelectIndices[selectIndex] = true
            cellData[self.cellSelectedTag] = true
            
            for i, v in pairs(needclosed) do
                if i ~= selectIndex and arrData[i] ~=nil then
                    arrData[i][self.cellSelectedTag] = false
                end
            end
            self._lastSelectIndex = selectIndex
            self.onItemSelect:Dispatch()
        else
            if self._allowSwitchOff then
                if cellData[self.cellSelectedTag] or self.mappedSelectIndices[selectIndex] then
                    cellData[self.cellSelectedTag] = false
                    self.mappedSelectIndices = {}
                end
                self._lastSelectIndex = 0
                self.onItemSelect:Dispatch()
            end
        end
    else
        if enable then
            self.mappedSelectIndices[selectIndex] = true
            self._lastSelectIndex = selectIndex
            self.onItemSelect:Dispatch()
        elseif self.mappedSelectIndices[selectIndex]~=nil then
            self.mappedSelectIndices[selectIndex] = nil
            self._lastSelectIndex = 0
            self.onItemSelect:Dispatch()
        end
        cellData[self.cellSelectedTag] = enable
    end
end



function ListDataHelper:__getArrData()
    return self.hostUIBase.data[self.hostDataName]
end


function ListDataHelper:__observer(trigger,key)
    if key == self.cellSelectedTag and self.hostUIBase == trigger.parent then
        print("ListDataHelper:observer" ..key)
        local selected = trigger.data[self.cellSelectedTag]
        if selected ~= self.mappedSelectIndices[trigger.data.index] then
            if not self._multiSelectable and not self._allowSwitchOff then
                if selected then
                    self:setIndexSelected(trigger.data.index,selected)
                else
                    if self.mappedSelectIndices[trigger.data.index] then
                        trigger.data[self.cellSelectedTag] = true
                    end
                end
            else
                self:setIndexSelected(trigger.data.index,selected)
            end
        end
    end
end

function ListDataHelper:_checkSelectable(trigger,key,value)
    return true
end


function ListDataHelper:destory()
    if  self.observerHandler ~= nil then
        self.hostUIBase:uninjectObservers(self.observerHandler);
    end
end



function ListDataHelper:printSnapshotData(data)
    print(self:printData(self:_snapShot(data),0))
end

function ListDataHelper:printData(data,deep)
    local deepStr = ""
    for i = 1, deep do
        deepStr = deepStr.."  "
    end
    local result = deepStr.."{".."\n"
    for i, v in pairs(data) do
        if type(v) == "table" then
            result = result..(i.."="..self:printData(v,deep+1))
        elseif type(v) == "function" then
            result = result..("function "..i).."\n"
        else
            result = result..(i.."= "..tostring(v)).."\n"
        end
    end
    result = result..deepStr.."}".."\n"
    return result
end

function ListDataHelper:_snapShot(data)
    if type(data) == "table" then
        local targetTable = {}
        for key, value in pairsUMT(data) do
            local snap = self:_snapShot(value)
            if snap~=nil then
                targetTable[key] = snap
            end
        end
        return targetTable
    elseif type(data) == "function" then
        return data
    else
        return data
    end
end




return ListDataHelper