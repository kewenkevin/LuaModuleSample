--- 数据模块存储部分，是一个空表，主要存在元表中，所以此类需要每次require创建
--- Generated by EmmyLua(https://github.com/EmmyLua)



---@class DataStoreModuleStorageFactory
local DataStoreModuleStorageFactory = {}

function DataStoreModuleStorageFactory.generate(module, mappedStates, data , keyName)
    local metaTable = DataStoreModuleStorageFactory.wrapState(module, mappedStates, data,keyName)
    return setmetatable({}, metaTable)
end

function getvarvalue (name)
    local value, found

    -- try local variables
    local i = 1
    while true do
        local n, v = debug.getlocal(2, i)
        if not n then break end
        if n == name then
            value = v
            found = true
        end
        i = i + 1
    end
    if found then return value end

    -- try upvalues
    local func = debug.getinfo(2).func
    i = 1
    while true do
        local n, v = debug.getupvalue(func, i)
        if not n then break end
        if n == name then return v end
        i = i + 1
    end

    -- not found; get global
    return getfenv(func)[name]
end

---@param module DataStoreModule
function DataStoreModuleStorageFactory.wrapState(module, mappedStates, data, keyName)
    local metaTable = {}

   
    metaTable.moduleName = keyName or module.moduleName

    --print("wrapState>>"..metaTable.moduleName)

    metaTable._values = {}
    metaTable._tables = {}
    metaTable._arrays = {}

    metaTable._handlers = {}
    metaTable._tableHandlers = {}
    metaTable._arrayHandlers = {}

    metaTable.self = module

    local _setValue = function(t, key, v)
        local m = mappedStates[key]
        if m then
            for i = 1, #m do
                local mk = m[i]
                if mk then
                    mk(t, v)
                end
            end
        end
    end

    local _setArray = function(key, value)
        local arr = {}
        for i, v in ipairs(value) do
            table.insert(arr, v)
        end
        arr.insert = function(value)
            table.insert(metaTable._arrays[key], value)

            local m = mappedStates[key .. "_insert"]
            if m then
                for i = 1, #m do
                    local mk = m[i]
                    if mk then
                        mk(metaTable._arrays[key], value)
                    end
                end
            end
        end
        arr.remove = function(v)
            if v > #arr then
                error("remove dont has this index in array: " .. v)
                return
            end
            local vx = metaTable._arrays[key][v]
            table.remove(metaTable._arrays[key], v)
            local m = mappedStates[key .. "_remove"]
            if m then
                for i = 1, #m do
                    local mk = m[i]
                    if mk then
                        mk(metaTable._arrays[key], v, vx)
                    end
                end
            end
        end
        metaTable._arrays[key] = arr
    end

    ---请求数据data 插入到元表的结构，后续通过setter getter访问
    ---不写入自身是为了隐藏这些属性，防止外部直接获取
    for key, value in pairs(data) do
        if type(value) == "table" then
            local type = "table"
            if value.type then
                type = value.type
            end
            if #value > 0 then
                type = "array"
            end
            if type == "table" then
                mappedStates[key] = mappedStates[key] or {}
                metaTable._tables[key] = metaTable.self:_generateInternalStorage(mappedStates[key], value,key)
                metaTable._tableHandlers[key] = function(v)
                    local old = metaTable._tables[key]
                    mappedStates[key] = mappedStates[key] or {}
                    metaTable._tables[key] = metaTable.self:_generateInternalStorage(mappedStates[key], v,key)
                    _setValue(old, key, v)
                end
            elseif type == "array" then
                _setArray(key, value)
                metaTable._arrayHandlers[key] = function(v)
                    local old = metaTable._arrays[key]
                    _setArray(key, v)
                    _setValue(old, key, v)
                end
            end
        else
            metaTable._values[key] = value
            metaTable._handlers[key] = function(v)
               local old = metaTable._values[key]
                metaTable._values[key] = v
                _setValue(old, key, v)
            end
        end
    end

    ---Get方法
    metaTable.__index = function(t, k)
        
        local result = metaTable._values[k]
        if result then
            return result
        elseif type(result) == "boolean" then
            return result
        end
        result = metaTable._tables[k]
        if result then
            return result
        end
        result = metaTable._arrays[k]
        if result then
            return result
        else
            --error("dont has this key :" .. k)
            return nil
        end
    end

    ---Set方法
    metaTable.__newindex = function(t, k, v)
        if type(v) == "table" then
            if metaTable._tableHandlers[k] then
                metaTable._tableHandlers[k](v)
            elseif metaTable._arrayHandlers[k] then
                metaTable._arrayHandlers[k](v)
            else
                local type = "table"
                if v.type then
                    type = v.type
                end
                if #v > 0 then
                    type = "array"
                end
                if type == "table" then
                    mappedStates[k] = mappedStates[k] or {}
                    metaTable._tables[k] = metaTable.self:_generateInternalStorage(mappedStates[k], v,k)
                    metaTable._tableHandlers[k] = function(nv)
                        local old =metaTable._tables[k]
                        mappedStates[k] = mappedStates[k] or {}
                        metaTable._tables[k] = metaTable.self:_generateInternalStorage(mappedStates[k], nv,k)
                        _setValue(old, k, nv)
                    end
                elseif type == "array" then
                    _setArray(k, v)
                    metaTable._arrayHandlers[k] = function(nv)
                        local old = metaTable._arrays[k]
                        _setArray(k, nv)
                        _setValue(old, k, nv)
                    end
                end
            end
        else
            local h = metaTable._handlers[k]
            if h then
                return h(v)
            else
                metaTable._values[k] = v
                metaTable._handlers[k] = function(v)
                    local old = metaTable._values[k]
                    metaTable._values[k] = v
                    _setValue(old, k, v)
                end
                _setValue(nil, k, v)
            end
        end
    end
    
    metaTable.__pairs = function(tbl)
        local index = 0
        local func = function(tbl, key)
            local nk, nv
            local processed = false
            if index == 0 then
                nk, nv = next(metaTable._values, key)
                if (nk == nil) then
                    index = index + 1
                    processed = false
                    key = nil
                else
                    processed = true
                end
            end
            if not processed and index == 1 then
                nk, nv = next(metaTable._tables, key)
                if (nk == nil) then
                    index = index + 1
                    processed = false
                    key = nil
                else
                    processed = true
                end
            end

            if not processed and index == 2 then
                nk, nv = next(metaTable._arrays, key)
                if (nk == nil) then
                    index = 0
                end
            end
            return nk, nv
        end

        return func, tbl, nil
    end
    
    return metaTable
end



return DataStoreModuleStorageFactory