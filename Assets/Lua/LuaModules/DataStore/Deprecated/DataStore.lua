--- 数据仓库入口类，实例化后对象为一个数据仓库，管理数据模块
--- Generated by EmmyLua(https://github.com/EmmyLua)

local DataStoreModule = require("LuaModules.DataStore.Deprecated.DataStoreModule")

---@class DataStoreDeprecated
---@field private mappedStates table<string,table>
---@field private modules table<string,DataStoreModule>
---@field public complicateMode boolean 为true复杂模式允许使用commit dispatch，否则不提供该接口,默认为true 允许使用
local DataStoreDeprecated = class("DataStoreDeprecated")

---@class DataStoreDeprecated.CtorParams
---@field public modules table<string, DataStoreModuleOption> module的初始化配置结构
DataStoreDeprecated.CtorParams = class("DataStoreDeprecated.ctorParams")

---initialize 构造初始化一个数据仓库对象，按照传入的options准备模块
---@param options DataStoreDeprecated.CtorParams
---@return DataStoreDeprecated
function DataStoreDeprecated.initialize(options)
    return DataStoreDeprecated.new(options)
end

---ctor 构造初始化一个数据仓库对象，按照传入的options准备模块
---@param options DataStoreDeprecated.CtorParams
function DataStoreDeprecated:ctor(options)
    self.mappedStates = {}
    self.complicateMode = true
    self:registerModule(options.modules)
    -- todo useless
    --@field public plugins function<DataStoreDeprecated>[] 一组扩展方法，在数仓准备好模块后调用
    --if options.plugins ~= nil then
    --    for i, v in ipairs(options.plugins) do
    --        v(self)
    --    end
    --end
end

---registerModule 注册一个模块哦
---@param modulesRequest table<string, DataStoreModuleOption>
function DataStoreDeprecated:registerModule(modulesRequest)
    self.modules = self.modules or {}

    if nil == modulesRequest then
        return
    end

    ---@param request DataStoreModuleOption
    for moduleName, request in pairs(modulesRequest) do
        local mappedStates = {}
        self.mappedStates[moduleName] = mappedStates

        ---基类为DataStoreModule 建立一个新的单例类 用来做数据模块
        local moduleClass = class("DataStoreModule."..moduleName,DataStoreModule);
        
        ---@type DataStoreModule
        local module = moduleClass.new(moduleName, request, self, mappedStates)

        self.modules[moduleName] = module

        self[moduleName] = self:getManager(moduleName)
    end


end

---unRegisterModule 反注册一个名字为modulesName的模块
---@param modulesName string
function DataStoreDeprecated:unRegisterModule(modulesName)
    if type(modulesName) == "string" then
        self.modules[modulesName] = nil
        self.mappedStates[modulesName] = nil
    end
end

---unRegisterGroup 反注册一组Module
---@param modules table<string, table> 反注册的一组，按照table键值反注册
function DataStoreDeprecated:unRegisterModules(modules)
    if type(modules) == "table" then
        for modulesName, v in pairs(modules) do
            self:unRegisterModule(modulesName)
        end
    end
end

---dispatch 触发某模块的manager中的某个方法
---@param moduleName string 模块名
---@param managerFuncName string 要出发的manger的方法名称
---@param params table 触发的manager方法的参数列表
function DataStoreDeprecated:dispatch(moduleName, managerFuncName, params)

    --非复杂模式
    if not self.complicateMode then
        error("this interface only support in complicateMode >> dispatch")
        return
    end

    local v = self.modules[moduleName]
    if not v then
        error("dont has this moduleName dispatch  " .. moduleName)
        return nil;
    end
    return v:dispatch(managerFuncName, params)
end

---getManagers 获取某个模块的manager
---@param moduleName string
---@return table<string,function>
function DataStoreDeprecated:getManager(moduleName)
    local v = self.modules[moduleName]
    if not v then
        error("dont has this moduleName dispatch  " .. moduleName)
        return nil;
    end
    return v:manager()
end

---commit 提交数据到某个模块的某个字段
---@param moduleName string
---@param propName string 参数名
---@param params table setter参数列表
function DataStoreDeprecated:commit(moduleName, propName, params)
    --非复杂模式
    if not self.complicateMode then
        error("this interface only support in complicateMode >> dispatch")
        return
    end
    local v = self.modules[moduleName]
    if not v then
        error("dont has this moduleName commit" .. moduleName)
        return nil;
    end
    return v:commit(propName, params)
end

---getter 调用某个模块的getter中propName的方法，返回数据
---@param moduleName string
---@param propName string
---@return any
function DataStoreDeprecated:getter(moduleName, propName)
    local v = self.modules[moduleName]
    if not v then
        error("error:dont hash this moduleName" .. moduleName)
        return nil;
    end
    return v:getter(propName)
end

---_toMapState
---@private
---@param mapState table
---@param moduleName string 模块名
---@param maps table|function
function DataStoreDeprecated:_toMapState(mapState, moduleName, maps)
    if not mapState then
        return
    end
    if type(maps) == "table" then
        for i, v in pairs(maps) do
            mapState[i] = mapState[i] or {}
            self:_toMapState(mapState[i], i, v)
        end
    elseif type(maps) == "function" then
        table.insert(mapState, 1, maps)
    else
        error("mapStates error map target must table or function: " .. moduleName)
    end
end

---_toUnmapState
---@private
---@param mapState table
---@param moduleName string
---@param maps table | function
function DataStoreDeprecated:_toUnmapState(mapState, moduleName, maps)
    if not mapState then
        return
    end
    if type(maps) == "table" then
        for i, v in pairs(maps) do
            mapState[i] = mapState[i] or {}
            self:_toUnmapState(mapState[i], i, v)
        end
    elseif type(maps) == "function" then
        for i = 1, #mapState do
            if mapState[i] == maps then
                table.remove(mapState, i)
                break
            end
        end
    else
        error("mapStates error map target must table or function: " .. moduleName)
    end
end

---mapStates 按table结构映射一个方法图和数据
---@param moduleName table
---@param maps table<string,function>
function DataStoreDeprecated:mapStates(moduleName, maps)
    self.mappedStates[moduleName] = self.mappedStates[moduleName] or {}
    self:_toMapState(self.mappedStates[moduleName], moduleName, maps)
end

---unmapStates 按table结构取消映射一个方法图和数据
---@param moduleName string
---@param maps table<string,function>
function DataStoreDeprecated:unmapStates(moduleName, maps)
    if self.mappedStates[moduleName] then
        self:_toUnmapState(self.mappedStates[moduleName], moduleName, maps)
    end
end

---mapAllStates 按table结构映射方法图和数据
---@param maps table<string,table>
function DataStoreDeprecated:mapAllStates(maps)
    if maps then
        for key, value in pairs(maps) do
            self:mapStates(key, value)
        end
    end
end

---unmapAllStates 按table结构取消映射方法图和数据
---@param maps table<string,table>
function DataStoreDeprecated:unmapAllStates(maps)
    if maps then
        for key, value in pairs(maps) do
            self:unmapStates(key, value)
        end
    end
end

---listenCall
---@param moduleName table
---@param maps table
---@param mapsFunc table
function DataStoreDeprecated:listenCall(moduleName, maps, mapsFunc)
    if maps == nil then
        error("error:dont listenCall this maps params is nil: " .. moduleName)
        return ;
    end
    local v = self.modules[moduleName]
    if not v then
        error("error:dont hash this moduleName: " .. moduleName)
        return ;
    end
    if not v.class.callback then
        v.class.callback = {}
    end
    if type(maps) == "table" then
        for k, f in pairs(maps) do
            v.class.callback[k] = v.class.callback[k] or {}
            table.insert(v.class.callback[k], f)
        end
    elseif type(maps) == "string" and mapsFunc ~= nil then
        v.class.callback[maps] = v.class.callback[maps] or {}
        table.insert(v.class.callback[maps], mapsFunc)
    else
        error("error:dont support this type: " .. type(maps))
    end
end

---unListenCall
---@param moduleName table
---@param maps table
---@param mapFunc table
function DataStoreDeprecated:unListenCall(moduleName, maps, mapFunc)
    local v = self.modules[moduleName]
    if not v then
        error("error:dont hash this moduleName: " .. moduleName)
        return ;
    end
    if not v.class.callback then
        return ;
    end
    if type(maps) == "table" then
        for k, f in pairs(maps) do
            if v.class.callback[k] then
                for i, x in ipairs(v.class.callback[k]) do
                    if x == f then
                        table.remove(v.class.callback[k], i)
                    end
                end
            end
        end
    elseif type(maps) == "string" and mapFunc ~= nil then
        if v.class.callback[maps] then
            for i, x in ipairs(v.class.callback[maps]) do
                if x == mapFunc then
                    table.remove(v.class.callback[maps], i)
                end
            end
        end
    else
        error("error:dont support this type: " .. type(maps))
    end
end

---listenAllCall 增加一组监听
---@param maps table<string,<string,function>> 第一个string是模块名，第二个string是监听事件名
function DataStoreDeprecated:listenAllCall(maps)
    if type(maps) == "table" then
        for k, v in pairs(maps) do
            self:listenCall(k, v)
        end
    else
        error("error:listenAllCall must a table in  this moduleName")
    end
end

---unListenAllCall 取消一组监听
---@param maps table<string,<string,function>> 第一个string是模块名，第二个string是监听事件名
function DataStoreDeprecated:unListenAllCall(maps)
    if type(maps) == "table" then
        for k, v in pairs(maps) do
            self:unListenCall(k, v)
        end
    else
        error("error:listenAllCall must a table in  this moduleName")
    end
end

return DataStoreDeprecated